# -*- coding: utf-8 -*-
"""ML_assign_2_q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1icvjln1u8ycvHmOS6VbEdZ_21xnMW_U6

Diabetes dataset using sklearn
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from sklearn import datasets, linear_model, metrics

diabetes = datasets.load_diabetes()
X = diabetes.data
y = diabetes.target

samp, natt = X.shape

for i in range(natt):
  attr_mean = np.mean(X[:,i])
  attr_std = np.std(X[:,i])
  X[:,i] = (X[:,i] - attr_mean)/attr_std

print(np.mean(X, axis = 0))
print(np.std(X, axis = 0))

samp, natt = X.shape

samp, natt

regressor = linear_model.LinearRegression(fit_intercept=False, normalize=False)
regressor.fit(X, y)

regressor.intercept_

regressor.coef_

y_pred = regressor.predict(X)
RSS = np.mean((y_pred-y)**2)/(np.std(y)**2)
Rsq = 1 - RSS
print(Rsq)
mse = np.mean((y_pred-y)**2)
print(mse)

"""Diabetes dataset without using sklearn"""

def MSE(X,y,w):
  y_pred = X.dot(w)
  return (1*np.linalg.norm(y_pred-y)**2)/442

def MSE_gradient(X,y,w):
  return (X.T.dot(X.dot(w)-y))/442

def gradient_descent(init, steps, grad):
  xs = [init]
  for step in steps:
    xs.append(xs[-1] - step * grad(X,y,xs[-1])) 
  return xs

n,d = samp,natt
w0 = np.random.normal(0,1,d)
ws = gradient_descent(w0,[0.1]*6000,MSE_gradient)

all_mse = []
for w in ws:
  mse = MSE(X,y,w)
  all_mse.append(mse)

for i in range(len(all_mse)):
  if i%500==0:
    print(f'MSE at interation {i} = {all_mse[i]}')

y_prediction = X.dot(ws[-1])
RSS_manual = np.mean((y_prediction-y)**2)/(np.std(y)**2)
Rsq_manual = 1-RSS;Rsq